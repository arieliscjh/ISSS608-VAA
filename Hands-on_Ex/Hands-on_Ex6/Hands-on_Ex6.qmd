---
title: "Hands-on_Ex6"
date: "February 6,2024"
date-modified: "last-modified"
execute: 
  eval: true 
  echo: true
  warning: false
editor: visual 
---

# 17 Visualizing and Analyzing Time-Oriented Data

## 17.1 Learning Outcome

-   plotting a calender heatmap

-   plotting a cycle plot

-   plotting a slopegraph

-   plotting a horizon chart

## 17.2 Getting Started

## 17.3 Loading R Package

```{r}
pacman::p_load(scales, viridis, lubridate, ggthemes, gridExtra, readxl, knitr, data.table, CGPfunctions, ggHoriPlot, tidyverse)
```

## 17.4 Plotting Calender Heatmap

### 17.4.1 The data

For the purpose of this hands-on exercise, *eventlog.csv* file will be used. This data file consists of 199,999 rows of time-series cyber attack records by country.

### 17.4.2 Importing the data

```{r}
attacks <- read_csv("data/eventlog.csv")
```

### 17.4.3 Examining the data structure

`kable()` can be used to review the structure of the imported data frame

```{r}
kable(head(attacks))
```

-   timestamp field stores date-time values in POSIXct format

-   source_country field stores the source of attack.

-   tz field stores time zone of the source IP address

### 17.4.4 Data Preparation

Step 1: Deriving weekday and hour of dayfields

Before we can plot the calender heatmap, two new fields namely wkday and hour need to be derived

```{r}
make_hr_wkday <- function(ts, sc, tz) {
  real_times <- ymd_hms(ts, 
                        tz = tz[1], 
                        quiet = TRUE)
  dt <- data.table(source_country = sc,
                   wkday = weekdays(real_times),
                   hour = hour(real_times))
  return(dt)
  }
```

-   [`ymd_hms()`](https://lubridate.tidyverse.org/reference/ymd_hms.html) and [`hour()`](https://lubridate.tidyverse.org/reference/hour.html) are from [**lubridate**](https://lubridate.tidyverse.org/) package, and

-   [`weekdays()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/weekdays) is a **base** R function.

Step 2: Deriving the attacks tibble data frame: put the label for weekday

```{r}

wkday_levels <- c('Saturday', 'Friday', 
                  'Thursday', 'Wednesday', 
                  'Tuesday', 'Monday', 
                  'Sunday')

attacks <- attacks %>%
  group_by(tz) %>%
  do(make_hr_wkday(.$timestamp, 
                   .$source_country, 
                   .$tz)) %>% 
  ungroup() %>% 
  mutate(wkday = factor(
    wkday, levels = wkday_levels),
    hour  = factor(
      hour, levels = 0:23))
```

`mutate()` of **dplyr** package is used to convert *wkday* and *hour* fields into **factor** so they'll be ordered when plotting

```{r}
kable(head(attacks))
```

### 17.4.5 Building the Calender Heatmaps

```{r}
grouped <- attacks %>% 
  count(wkday, hour) %>% 
  ungroup() %>%
  na.omit()

ggplot(grouped, 
       aes(hour, 
           wkday, 
           fill = n)) + 
geom_tile(color = "white", 
          size = 0.1) + 
theme_tufte(base_family = "Helvetica") + 
coord_equal() +
scale_fill_gradient(name = "# of attacks",
                    low = "sky blue", 
                    high = "dark blue") +
labs(x = NULL, 
     y = NULL, 
     title = "Attacks by weekday and time of day") +
theme(axis.ticks = element_blank(),
      plot.title = element_text(hjust = 0.5),
      legend.title = element_text(size = 8),
      legend.text = element_text(size = 6) )
```

Things to learn:

-   a tibble data table called *grouped* is derived by aggregating the attack by *wkday* and *hour* fields.

-   a new field called *n* is derived by using `group_by()` and `count()` functions.

-   `na.omit()` is used to exclude missing value.

-   `geom_tile()` is used to plot tiles (grids) at each x and y position. `color` and `size` arguments are used to specify the border color and line size of the tiles.

-   [`theme_tufte()`](https://jrnold.github.io/ggthemes/reference/theme_tufte.html) of [**ggthemes**](https://jrnold.github.io/ggthemes/reference/) package is used to remove unnecessary chart junk. To learn which visual components of default ggplot2 have been excluded, you are encouraged to comment out this line to examine the default plot.

-   `coord_equal()` is used to ensure the plot will have an aspect ratio of 1:1.

-   `scale_fill_gradient()` function is used to creates a two colour gradient (low-high).

### 17.4.6 Building multiple calendar heatmaps

Objective: Building multiple heatmaps for the top four countries with the highest number of attacks

### 17.4.7 Plotting multiple calendar heatmaps

Step 1: Deriving attack by country object

In order to identify the top 4 countries with the highest number of attacks,

-   count number of attacks by country

-   calculate the percent of attacks by country

-   save the results in a tibble data frame

```{r}
#| eval: false
attacks_by_country <- count(
  attacks, source_country) %>%
  mutate(percent = percent(n/sum(n))) %>%
  arrange(desc(n))
```

Step 2: you are required to extract the attack records of the top 4 countries from attacks data frame and save the data in a new tibble data frame

```{r}
#| eval: false
top4 <- attacks_by_country$source_country[1:4]
top4_attacks <- attacks %>%
  filter(source_country %in% top4) %>%
  count(source_country, wkday, hour) %>%
  ungroup() %>%
  mutate(source_country = factor(
    source_country, levels = top4)) %>%
  na.omit()
```

### 17.4.8 Plotting Multiple Calendar Heatmaps

Step 3: Plotting the multiple calender heatmap

```{r}
#| eval: false
ggplot(top4_attacks, 
       aes(hour, 
           wkday, 
           fill = n)) + 
  geom_tile(color = "white", 
          size = 0.1) + 
  theme_tufte(base_family = "Helvetica") + 
  coord_equal() +
  scale_fill_gradient(name = "# of attacks",
                    low = "sky blue", 
                    high = "dark blue") +
  facet_wrap(~source_country, ncol = 2) +
  labs(x = NULL, y = NULL, 
     title = "Attacks on top 4 countries by weekday and time of day") +
  theme(axis.ticks = element_blank(),
        axis.text.x = element_text(size = 7),
        plot.title = element_text(hjust = 0.5),
        legend.title = element_text(size = 8),
        legend.text = element_text(size = 6) )
```

### 17.5 Plotting Cycle plot

In this section, you will learn how to plot a cycle plot showing the time-series pattern and trend of visitor arrivals from vn programmatically

### 17.5.1 Data Import

```{r}
air <- read_excel("data/arrivals_by_air.xlsx")
```

### 17.5.2 Step 2: Deriving month and year fields

```{r}
air$month <- factor(month(air$`Month-Year`), 
                    levels=1:12, 
                    labels=month.abb, 
                    ordered=TRUE) 
air$year <- year(ymd(air$`Month-Year`))
```

### 17.5.3 Step 4: Extracting the target country

```{r}
Vietnam <- air %>% 
  select(`Vietnam`, 
         month, 
         year) %>%
  filter(year >= 2010)
```

### 17.5.4 Step 5: Computing year average arrivals by month

```{r}
hline.data <- Vietnam %>% 
  group_by(month) %>%
  summarise(avgvalue = mean(`Vietnam`))
```

### 17.5.5 Step 6: plotting the cycle plot

```{r}
ggplot() + 
  geom_line(data=Vietnam,
            aes(x=year, 
                y=`Vietnam`, 
                group=month), 
            colour="black") +
  geom_hline(aes(yintercept=avgvalue), 
             data=hline.data, 
             linetype=6, 
             colour="red", 
             size=0.5) + 
  facet_grid(~month) +
  labs(axis.text.x = element_blank(),
       title = "Visitor arrivals from Vietnam by air, Jan 2010-Dec 2019") +
  xlab("") +
  ylab("No. of Visitors") +
  theme_tufte(base_family = "Helvetica")
```

## 17.6 Plotting slopegraph

### 17.6.1 Step 1: Data Import

```{r}
rice <- read_csv("data/rice.csv")
```

### 17.6.2 Step 2: plotting the slopegraph

```{r}
rice %>% 
  mutate(Year = factor(Year)) %>%
  filter(Year %in% c(1961, 1980)) %>%
  newggslopegraph(Year, Yield, Country,
                Title = "Rice Yield of Top 11 Asian Counties",
                SubTitle = "1961-1980",
                Caption = "Prepared by: Dr. Kam Tin Seong")
```

For effective data visualisation design, `factor()` is used convert the value type of *Year* field from numeric to factor.
